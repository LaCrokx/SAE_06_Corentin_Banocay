stages:
  - lint
  - build
  - deploy

hadolint:
  stage: lint
  script:
    - docker run --rm -v "$(pwd):/app" -w /app hadolint/hadolint hadolint Dockerfile


variables:
  # Tag image with short commit SHA for unique versioning
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  LATEST_TAG: $CI_REGISTRY_IMAGE:latest

build:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $IMAGE_TAG -t $LATEST_TAG .
    - docker push $IMAGE_TAG
    - docker push $LATEST_TAG

deploy:
  stage: deploy
  before_script:
    # Use kubeconfig file already present on the runner
    - export KUBECONFIG=/etc/gitlab-runner/kubeconfig/config
    - kubectl version --client
  script:
    - echo "Deploying version $IMAGE_TAG to Kubernetes cluster"
    # Create namespace if it doesn't exist
    - kubectl create namespace addrservice --dry-run=client -o yaml | kubectl apply -f -
    # Create docker registry secret for pulling images from GitLab Registry
    # Use long-lived tokens (K8S_REGISTRY_*) instead of CI_JOB_TOKEN which expires
    - kubectl create secret docker-registry gitlab-registry 
        --docker-server=$CI_REGISTRY 
        --docker-username=${K8S_REGISTRY_USER:-$CI_REGISTRY_USER} 
        --docker-password=${K8S_REGISTRY_PASSWORD:-$CI_REGISTRY_PASSWORD} 
        --docker-email=gitlab@example.com
        -n addrservice --dry-run=client -o yaml | kubectl apply -f -
    # Apply Kubernetes deployment manifest (with env variable substitution)
    - export CI_REGISTRY_IMAGE CI_COMMIT_SHORT_SHA
    - envsubst < k8s/deployment.yaml | kubectl apply -f -
    # Wait for rollout to complete
    - kubectl rollout status deployment/addrservice -n addrservice --timeout=5m
    # Display deployment info
    - kubectl get pods -n addrservice
    - kubectl get svc -n addrservice
  only:
    - main
