---
- name: Déploiement du Microservice Python sur GitLab
  hosts: gitlab
  gather_facts: no
  vars:
    gitlab_host: "{{ ansible_host }}"
    gitlab_url: "http://127.0.0.1"  # Accès GitLab localement sur la VM
    project_name: "python-microservice-tornado"
    project_path: "root/{{ project_name }}"
    local_repo_path: "/tmp/{{ project_name }}"
    source_path: "/tmp/microservice-source"  # Sera copié ici d'abord
    gitlab_user: "root"
    
  tasks:
    - name: Copie des fichiers sources du microservice vers la VM GitLab
      synchronize:
        src: "{{ playbook_dir }}/../tutorial-python-microservice-tornado-master/"
        dest: "{{ source_path }}/"
        recursive: yes
        delete: no
        rsync_opts:
          - "--exclude=.git"
          - "--exclude=.venv"
          - "--exclude=__pycache__"
          - "--exclude=*.pyc"

    - name: Attente de l'accessibilité de GitLab
      uri:
        url: "{{ gitlab_url}}/"
        status_code: 200,302
        timeout: 10
        follow_redirects: none
      register: gitlab_ready
      until: gitlab_ready.status in [200, 302]
      retries: 30
      delay: 10

    - name: Récupération du mot de passe root GitLab (installation barebone)
      shell: grep 'Password:' /etc/gitlab/initial_root_password 2>/dev/null | awk '{print $2}' || grep Password /root/gitlab_credentials.txt 2>/dev/null | awk '{print $2}'
      register: gitlab_password_result
      changed_when: false
      failed_when: false

    - name: Définition du fait gitlab_password
      set_fact:
        gitlab_password: "{{ gitlab_password_result.stdout | trim }}"

    - name: Affichage des identifiants GitLab
      debug:
        msg:
          - "URL GitLab : {{ gitlab_url }}"
          - "Utilisateur : {{ gitlab_user }}"
          - "Mot de passe : {{ gitlab_password }}"

    - name: Création d'un Personal Access Token GitLab via la console Rails
      shell: |
        gitlab-rails runner "
        user = User.find_by(username: 'root')
        token = user.personal_access_tokens.create(
          name: 'automation-token',
          scopes: ['api', 'write_repository', 'read_repository'],
          expires_at: 365.days.from_now
        )
        puts token.token
        " 2>/dev/null | tail -1
      register: token_creation
      changed_when: false
      failed_when: false

    - name: Définition du token API
      set_fact:
        api_token: "{{ token_creation.stdout | trim }}"
      when: token_creation.stdout is defined and token_creation.stdout != ""

    - name: Vérification de l'existence du projet
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_path | urlencode }}"
        method: GET
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        status_code: [200, 404]
        validate_certs: no
      register: project_check
      when: api_token is defined

    - name: Création du projet GitLab via l'API
      uri:
        url: "{{ gitlab_url }}/api/v4/projects"
        method: POST
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        body_format: json
        body:
          name: "{{ project_name }}"
          path: "{{ project_name }}"
          visibility: "public"
          initialize_with_readme: false
        status_code: [200, 201, 400]  # 400 = existe déjà
        validate_certs: no
      register: project_response
      when: 
        - api_token is defined
        - project_check.status == 404
      failed_when: false

    - name: Récupération des informations du projet (pour avoir l'ID)
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/root%2F{{ project_name }}"
        method: GET
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        status_code: [200, 404]
        validate_certs: no
      register: project_info
      when: api_token is defined
      failed_when: false

    - name: Affichage des informations du projet
      debug:
        msg:
          - "Projet créé/existant à : {{ gitlab_url }}/{{ project_path }}"
          - "ID du Projet : {{ project_info.json.id | default('1') }}"

    - name: Suppression du dépôt local existant si présent
      file:
        path: "{{ local_repo_path }}"
        state: absent

    - name: Création du répertoire du dépôt local
      file:
        path: "{{ local_repo_path }}"
        state: directory
        mode: '0755'

    - name: Initialisation du dépôt git
      shell: |
        cd {{ local_repo_path }}
        git init
        git config user.name "Administrator"
        git config user.email "admin@example.com"
      args:
        executable: /bin/bash

    - name: Copie des fichiers du microservice Python vers le dépôt
      command: cp -r "{{ source_path }}/." "{{ local_repo_path }}/"

    - name: Suppression du répertoire .venv copié
      file:
        path: "{{ local_repo_path }}/.venv"
        state: absent

    - name: Suppression du répertoire __pycache__ copié
      file:
        path: "{{ local_repo_path }}/__pycache__"
        state: absent

    - name: Suppression des fichiers .pyc copiés
      command: find "{{ local_repo_path }}" -name '*.pyc' -delete

    - name: Vérification de l'existence de .gitlab-ci.yml
      stat:
        path: "{{ local_repo_path }}/.gitlab-ci.yml"
      register: gitlab_ci_file

    - name: Affichage de l'état CI/CD
      debug:
        msg: "{{ '.gitlab-ci.yml trouvé - Le pipeline CI/CD sera déclenché' if gitlab_ci_file.stat.exists else '.gitlab-ci.yml NON trouvé - Le CI/CD ne s exécutera pas automatiquement' }}"

    - name: Ajout du remote git
      shell: |
        cd {{ local_repo_path }}
        # Encodage URL du mot de passe pour le remote git
        ENCODED_PASS=$(echo "{{ gitlab_password }}" | sed 's/+/%2B/g; s/\//%2F/g; s/=/%3D/g')
        git remote add origin "http://{{ gitlab_user }}:${ENCODED_PASS}@127.0.0.1/{{ project_path }}.git" || true
      args:
        executable: /bin/bash
      when: gitlab_password != ""

    - name: Ajout de tous les fichiers à git
      shell: |
        cd {{ local_repo_path }}
        git add .
      args:
        executable: /bin/bash

    - name: Commit des fichiers
      shell: |
        cd {{ local_repo_path }}
        git commit -m "Commit initial : Microservice Python Tornado" || true
      args:
        executable: /bin/bash

    - name: Renommage de la branche en main
      shell: |
        cd {{ local_repo_path }}
        git branch -M main
      args:
        executable: /bin/bash

    - name: Déprotection de la branche main pour permettre le push
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_info.json.id }}/protected_branches/main"
        method: DELETE
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        status_code: [204, 404]  # 204 = supprimé, 404 = non protégé
        validate_certs: no
      register: unprotect_result
      when: 
        - api_token is defined
        - project_info.json.id is defined
      failed_when: false

    - name: Push vers GitLab
      shell: |
        cd {{ local_repo_path }}
        git push -u origin main --force
      args:
        executable: /bin/bash
      register: push_result
      when: gitlab_password != ""

    - name: Affichage du résultat du push
      debug:
        var: push_result.stdout_lines
      when: push_result is defined

    - name: Création de la variable K8S_REGISTRY_USER
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_info.json.id }}/variables"
        method: POST
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        body_format: json
        body:
          key: "K8S_REGISTRY_USER"
          value: "{{ gitlab_user }}"
          protected: false
          masked: false
        status_code: [201, 400] # 400 si la variable existe déjà
        validate_certs: no
      when: 
        - api_token is defined
        - project_info.json.id is defined
      failed_when: false

    - name: Création de la variable K8S_REGISTRY_PASSWORD
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_info.json.id }}/variables"
        method: POST
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        body_format: json
        body:
          key: "K8S_REGISTRY_PASSWORD"
          value: "{{ api_token }}"
          protected: false
          masked: true
        status_code: [201, 400] # 400 si la variable existe déjà
        validate_certs: no
      when: 
        - api_token is defined
        - project_info.json.id is defined
      failed_when: false

    - name: Déclenchement du pipeline CI/CD
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_info.json.id }}/pipeline"
        method: POST
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        body_format: json
        body:
          ref: "main"
        status_code: [200, 201]
        validate_certs: no
      register: pipeline_response
      when: 
        - api_token is defined
        - gitlab_ci_file.stat.exists
        - project_info.json.id is defined
      failed_when: false

    - name: Création du Runner GitLab via l'API
      uri:
        url: "{{ gitlab_url }}/api/v4/user/runners"
        method: POST
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        body_format: json
        body:
          runner_type: "instance_type"
          description: "Runner Shell Automatisé"
          tag_list: ["shell", "docker", "automated"]
          run_untagged: true
          locked: false
        status_code: [201, 400]  # 400 si le runner existe déjà
        validate_certs: no
      register: runner_create_response
      when: api_token is defined
      failed_when: false

    - name: Extraction du token d'authentification du runner
      set_fact:
        runner_token: "{{ runner_create_response.json.token }}"
      when: 
        - runner_create_response.json is defined
        - runner_create_response.json.token is defined

    - name: Enregistrement du Runner GitLab avec la commande gitlab-runner
      shell: |
        gitlab-runner register \
          --non-interactive \
          --url "{{ gitlab_url }}" \
          --token "{{ runner_token }}" \
          --executor "shell" \
          --description "Runner Shell Automatisé"
      register: runner_register_result
      when: runner_token is defined
      failed_when: false
      changed_when: "'Runner registered successfully' in runner_register_result.stderr or 'Registered runner' in runner_register_result.stderr"

    - name: Assurance que le service GitLab Runner est démarré
      systemd:
        name: gitlab-runner
        state: started
        enabled: yes
      when: runner_token is defined
      failed_when: false

    - name: Affichage de l'état d'enregistrement du runner
      debug:
        msg:
          - "Enregistrement du Runner terminé"
          - "Token du Runner : {{ runner_token | default('Non créé') }}"
          - "Sortie de l'enregistrement : {{ runner_register_result.stderr | default('N/A') }}"
      when: runner_token is defined

    - name: Affichage des informations du pipeline
      debug:
        msg:
          - "========================================="
          - "Déploiement Terminé !"
          - "========================================="
          - "URL du Projet GitLab : {{ gitlab_url }}/{{ project_path }}"
          - "Dépôt poussé avec succès !"
          - "Statut du Pipeline CI/CD : {{ 'Déclenché - ID Pipeline : ' + (pipeline_response.json.id | string) if pipeline_response is defined and pipeline_response.status == 201 else 'Non déclenché (vérifiez .gitlab-ci.yml)' }}"
          - ""
          - "Prochaines étapes :"
          - "1. Visitez {{ gitlab_url }}/{{ project_path }}"
          - "2. Enregistrez un Runner GitLab si ce n'est pas déjà fait"
          - "3. Surveillez le pipeline CI/CD : {{ gitlab_url }}/{{ project_path }}/-/pipelines"
          - "========================================="
