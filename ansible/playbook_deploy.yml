---
- name: Deploy Python Microservice to GitLab
  hosts: gitlab
  gather_facts: no
  vars:
    gitlab_host: "{{ ansible_host }}"
    gitlab_url: "http://127.0.0.1"  # Access GitLab locally on the VM
    project_name: "python-microservice-tornado"
    project_path: "root/{{ project_name }}"
    local_repo_path: "/tmp/{{ project_name }}"
    source_path: "/tmp/microservice-source"  # Will copy source here first
    gitlab_user: "root"
    
  tasks:
    - name: Copy microservice source files to GitLab VM
      synchronize:
        src: "{{ playbook_dir }}/../tutorial-python-microservice-tornado-master/"
        dest: "{{ source_path }}/"
        recursive: yes
        delete: no
        rsync_opts:
          - "--exclude=.git"
          - "--exclude=.venv"
          - "--exclude=__pycache__"
          - "--exclude=*.pyc"

    - name: Wait for GitLab to be accessible
      uri:
        url: "{{ gitlab_url}}/"
        status_code: 200,302
        timeout: 10
        follow_redirects: none
      register: gitlab_ready
      until: gitlab_ready.status in [200, 302]
      retries: 30
      delay: 10

    - name: Get GitLab root password (barebone installation)
      shell: grep 'Password:' /etc/gitlab/initial_root_password 2>/dev/null | awk '{print $2}' || grep Password /root/gitlab_credentials.txt 2>/dev/null | awk '{print $2}'
      register: gitlab_password_result
      changed_when: false
      failed_when: false

    - name: Set GitLab password
      set_fact:
        gitlab_password: "{{ gitlab_password_result.stdout | trim }}"

    - name: Display GitLab credentials
      debug:
        msg:
          - "GitLab URL: {{ gitlab_url }}"
          - "Username: {{ gitlab_user }}"
          - "Password: {{ gitlab_password }}"

    - name: Create GitLab Personal Access Token via Rails console
      shell: |
        gitlab-rails runner "
        user = User.find_by(username: 'root')
        # Remove existing token if it exists
        user.personal_access_tokens.find_by(name: 'automation-token')&.revoke!
        # Create new token with registry scope
        token = user.personal_access_tokens.create(
          name: 'automation-token',
          scopes: ['api', 'write_repository', 'read_repository', 'write_registry'],
          expires_at: 365.days.from_now
        )
        puts token.token
        " 2>/dev/null | tail -1
      register: token_creation
      changed_when: false
      failed_when: false

    - name: Set API token
      set_fact:
        api_token: "{{ token_creation.stdout | trim }}"
      when: token_creation.stdout is defined and token_creation.stdout != ""

    - name: Check if project already exists
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_path | urlencode }}"
        method: GET
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        status_code: [200, 404]
        validate_certs: no
      register: project_check
      when: api_token is defined

    - name: Create GitLab project via API
      uri:
        url: "{{ gitlab_url }}/api/v4/projects"
        method: POST
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        body_format: json
        body:
          name: "{{ project_name }}"
          path: "{{ project_name }}"
          visibility: "public"
          initialize_with_readme: false
        status_code: [200, 201, 400]  # 400 = already exists
        validate_certs: no
      register: project_response
      when: 
        - api_token is defined
        - project_check.status == 404
      failed_when: false

    - name: Fetch project information (to get ID in all cases)
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/root%2F{{ project_name }}"
        method: GET
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        status_code: [200, 404]
        validate_certs: no
      register: project_info
      when: api_token is defined
      failed_when: false

    - name: Display project information
      debug:
        msg:
          - "Project created/exists at: {{ gitlab_url }}/{{ project_path }}"
          - "Project ID: {{ project_info.json.id | default('1') }}"

    - name: Remove existing local repository if present
      file:
        path: "{{ local_repo_path }}"
        state: absent

    - name: Create local repository directory
      file:
        path: "{{ local_repo_path }}"
        state: directory
        mode: '0755'

    - name: Initialize git repository
      shell: |
        cd {{ local_repo_path }}
        git init
        git config user.name "Administrator"
        git config user.email "admin@example.com"
      args:
        executable: /bin/bash

    - name: Copy Python microservice files to repo (including hidden files)
      shell: |
        cp -r {{ source_path }}/. {{ local_repo_path }}/
        # Remove unwanted directories if they were copied
        rm -rf {{ local_repo_path }}/.venv {{ local_repo_path }}/__pycache__
        find {{ local_repo_path }} -name '*.pyc' -delete
      args:
        executable: /bin/bash

    - name: Verify .gitlab-ci.yml exists
      stat:
        path: "{{ local_repo_path }}/.gitlab-ci.yml"
      register: gitlab_ci_file

    - name: Display CI/CD status
      debug:
        msg: "{{ '.gitlab-ci.yml found - CI/CD pipeline will be triggered' if gitlab_ci_file.stat.exists else '.gitlab-ci.yml NOT found - CI/CD will not run automatically' }}"

    - name: Add git remote
      shell: |
        cd {{ local_repo_path }}
        # URL-encode password for git remote (replace + with %2B, / with %2F, = with %3D)
        ENCODED_PASS=$(echo "{{ gitlab_password }}" | sed 's/+/%2B/g; s/\//%2F/g; s/=/%3D/g')
        git remote add origin "http://{{ gitlab_user }}:${ENCODED_PASS}@127.0.0.1/{{ project_path }}.git" || true
      args:
        executable: /bin/bash
      when: gitlab_password != ""

    - name: Add all files to git
      shell: |
        cd {{ local_repo_path }}
        git add .
      args:
        executable: /bin/bash

    - name: Commit files
      shell: |
        cd {{ local_repo_path }}
        git commit -m "Initial commit: Python Tornado microservice" || true
      args:
        executable: /bin/bash

    - name: Set main branch
      shell: |
        cd {{ local_repo_path }}
        git branch -M main
      args:
        executable: /bin/bash

    - name: Unprotect main branch to allow push
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_info.json.id }}/protected_branches/main"
        method: DELETE
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        status_code: [204, 404]  # 204 = deleted, 404 = not protected
        validate_certs: no
      register: unprotect_result
      when: 
        - api_token is defined
        - project_info.json.id is defined
      failed_when: false

    - name: Push to GitLab
      shell: |
        cd {{ local_repo_path }}
        git push -u origin main --force
      args:
        executable: /bin/bash
      register: push_result
      when: gitlab_password != ""

    - name: Display push result
      debug:
        var: push_result.stdout_lines
      when: push_result is defined

    - name: Delete K8S_REGISTRY_USER variable if exists
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_info.json.id }}/variables/K8S_REGISTRY_USER"
        method: DELETE
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        status_code: [204, 404]
        validate_certs: no
      when: api_token is defined
      failed_when: false

    - name: Create K8S_REGISTRY_USER variable
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_info.json.id }}/variables"
        method: POST
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        body_format: json
        body:
          key: "K8S_REGISTRY_USER"
          value: "{{ gitlab_user }}"
          masked: false
        status_code: [201]
        validate_certs: no
      when: api_token is defined

    - name: Delete K8S_REGISTRY_PASSWORD variable if exists
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_info.json.id }}/variables/K8S_REGISTRY_PASSWORD"
        method: DELETE
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        status_code: [204, 404]
        validate_certs: no
      when: api_token is defined
      failed_when: false

    - name: Create K8S_REGISTRY_PASSWORD variable
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_info.json.id }}/variables"
        method: POST
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        body_format: json
        body:
          key: "K8S_REGISTRY_PASSWORD"
          value: "{{ gitlab_password }}"
          masked: true
        status_code: [201]
        validate_certs: no
      when: api_token is defined

    - name: Trigger CI/CD pipeline
      uri:
        url: "{{ gitlab_url }}/api/v4/projects/{{ project_info.json.id }}/pipeline"
        method: POST
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        body_format: json
        body:
          ref: "main"
        status_code: [200, 201]
        validate_certs: no
      register: pipeline_response
      when: 
        - api_token is defined
        - gitlab_ci_file.stat.exists
        - project_info.json.id is defined
      failed_when: false

    - name: Create GitLab Runner via API
      uri:
        url: "{{ gitlab_url }}/api/v4/user/runners"
        method: POST
        headers:
          PRIVATE-TOKEN: "{{ api_token }}"
        body_format: json
        body:
          runner_type: "instance_type"
          description: "Automated Shell Runner"
          tag_list: ["shell", "docker", "automated"]
          run_untagged: true
          locked: false
        status_code: [201, 400]  # 400 if runner already exists
        validate_certs: no
      register: runner_create_response
      when: api_token is defined
      failed_when: false

    - name: Extract runner authentication token
      set_fact:
        runner_token: "{{ runner_create_response.json.token }}"
      when: 
        - runner_create_response.json is defined
        - runner_create_response.json.token is defined

    - name: Register GitLab Runner with gitlab-runner command
      shell: |
        gitlab-runner register \
          --non-interactive \
          --url "{{ gitlab_url }}" \
          --token "{{ runner_token }}" \
          --executor "shell" \
          --description "Automated Shell Runner"
      register: runner_register_result
      when: runner_token is defined
      failed_when: false
      changed_when: "'Runner registered successfully' in runner_register_result.stderr or 'Registered runner' in runner_register_result.stderr"

    - name: Ensure GitLab Runner service is running
      systemd:
        name: gitlab-runner
        state: started
        enabled: yes
      when: runner_token is defined
      failed_when: false

    - name: Display runner registration status
      debug:
        msg:
          - "Runner registration completed"
          - "Runner token: {{ runner_token | default('Not created') }}"
          - "Registration output: {{ runner_register_result.stderr | default('N/A') }}"
      when: runner_token is defined

    - name: Display pipeline information
      debug:
        msg:
          - "========================================="
          - "Deployment Complete!"
          - "========================================="
          - "GitLab Project URL: {{ gitlab_url }}/{{ project_path }}"
          - "Repository pushed successfully!"
          - "CI/CD Pipeline Status: {{ 'Triggered - Pipeline ID: ' + (pipeline_response.json.id | string) if pipeline_response is defined and pipeline_response.status == 201 else 'Not triggered (check .gitlab-ci.yml)' }}"
          - ""
          - "Next steps:"
          - "1. Visit {{ gitlab_url }}/{{ project_path }}"
          - "2. Register a GitLab Runner if not already done"
          - "3. Monitor CI/CD pipeline: {{ gitlab_url }}/{{ project_path }}/-/pipelines"
          - "========================================="
